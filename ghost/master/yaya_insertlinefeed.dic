//******************************************************************************
// 自動改行関数の辞書
// - SAORI"kisaragi"を用いて形態素解析を行い、
//   文節単位で読みやすく改行を入れる関数
// - 参考: https://qiita.com/shimajiroxyz/items/e44058af8b036f5354aa
//******************************************************************************

InsertLineFeed
{
  // 文字数計算のため、OnTranslate処理をこちらで先に行う
  willTranslate = 0
  _text = TextOnlyTranslator(_argv[0], 'TextOnlyTranslatorFunc')

  InsertLineFeed.Exec(_text)
}

//自動改行(文節区切りで改行するようにする。kisaragiが必要)
InsertLineFeed.Exec
{
  InsertLineFeed.Wakachi(_argv[0])
  InsertLineFeed.Render()
}

// 文字列を文節に分割し、配列に格納する
InsertLineFeed.Wakachi
{
  InsertLineFeed.wakachi = (IARRAY, '')

  // _argv[0]: 改行を入れたい文字列
  _text = _argv[0]

  // _wordcountはスコープの数だけ要る とりあえず10確保
  _ary = IARRAY
  for _j=0; _j<10; _j++ {
    _ary = (_ary, 0)
  }
  _wordcount = _ary

  // 直前・直後に改行を入れる品詞と単語を列挙
  _htarget = '名詞, 動詞, 接頭詞, 副詞, 感動詞, 形容詞, 形容動詞, 連体詞'

  // 内部処理に影響しなさそうな制御文字
  _tagmark = CHR(28)
  _delim = CHR(31)

  _text = RE_REPLACEEX(_text, '(\\n|\\_l\[0|\\x|\\c|\\[01]|\\p\[\d+\])', _delim+'$1')

  // 元の文字列を_delimで区切って各々処理する
  _lines = SPLIT(_text, _delim)

  for _i=0; _i<ARRAYSIZE(_lines); _i++ {
    _line = _lines[_i]

    // 文字カウント・形態素解析に支障をきたすのでさくらスクリプトを目印用文字列に置換
    _l = RE_REPLACE(_line, '\\_{0,2}[a-zA-Z0-9*!&](\d|\[("([^"]|\\")+?"|([^\]]|\\\])+?)+?\])?', _tagmark)

    // 置換したさくらスクリプトは配列に保持しておいて適宜取り出す
    _tags = RE_GETSTR

    // さくらスクリプトを取り出す際のインデックス
    _tagcount = 0

    // 単語に分割する。_rankは単語の総数
    _rank = FUNCTIONEX('SAORI\kisaragi\kisaragi.dll', 'parse', _l)

    _inBrackets = 0
    _lastInBrackets = 0
    _afterOpenBracket = 0
    _afterCloseBracket = 0
    _afterPrePos = 0
    _afterSahenNoun = 0

    for _j=0; _j<_rank-1; _j++ {
      // 最後の単語はEOSなのでrank-1でよい

      // _wordに平文の単語を取り出す
      _word = valueex[_j][0, CHR(9)]

      if _tagmark _in_ _word {
        // _wordに_tagmark(さくらスクリプト)が含まれている場合、
        // 検出した数だけリストから取り出して_tagmarkの位置に挿入
        for _k=0; _k<RE_GREP(_word,_tagmark); _k++ {
          InsertLineFeed.wakachi[ARRAYSIZE(InsertLineFeed.wakachi) - 1] += _tags[_tagcount]
          _tagcount++
        }

        // _wordから_tagmarkを削除
        // でも多分平文と_tagmarkが混在していることはないのでcontinueでいいかも
        _word = RE_REPLACE(_word, _tagmark, '')
      }

      _posinfo = valueex[_j][3, CHR(9)]
      _sp = STRSTR(_posinfo, '-', 0)
      _pos = SUBSTR(_posinfo, 0, _sp)
      _pos_detail = ERASE(_posinfo, 0, _sp+1)

      _noBreak = _pos !_in_ _htarget
      _noBreak = _noBreak || '接尾' _in_ _pos_detail
      _noBreak = _noBreak || (_pos == '動詞' && 'サ変接続' _in_ _pos_detail)
      _noBreak = _noBreak || '非自立' _in_ _pos_detail
      _noBreak = _noBreak || _afterPrePos
      _noBreak = _noBreak || (_afterSahenNoun && 'サ変動詞' _in_ _pos_detail)
      _noBreak = _noBreak || _afterOpenBracket
      _noBreak = _noBreak || '括弧閉' _in_ _pos_detail
      _noBreak = _noBreak || 'ナイ形容詞語幹' _in_ _pos_detail
      _noBreak = _noBreak || '特殊・ナイ' _in_ valueex[_j][4, CHR(9)]
      _noBreak = _noBreak || '特殊・タ' _in_ valueex[_j][4, CHR(9)]

      if _afterCloseBracket || '括弧開' _in_ _pos_detail {
        _noBreak = 0
      }

      if !_noBreak {
        // 改行処理
        InsertLineFeed.wakachi ,= ''
      }

      // 現在行に追加
      InsertLineFeed.wakachi[ARRAYSIZE(InsertLineFeed.wakachi) - 1] += _word

      _afterCloseBracket = _inBrackets != _lastInBrackets && _inBrackets == 0
      _afterPrePos = _pos == '接頭詞'
      _afterSahenNoun = 'サ変接続' _in_ _pos_detail
      _afterOpenBracket = '括弧開' _in_ _pos_detail
    }

    InsertLineFeed.wakachi ,= ''
  }

  for _i=0; _i<ARRAYSIZE(InsertLineFeed.wakachi); _i++ {
    if InsertLineFeed.wakachi[_i] == '' {
      InsertLineFeed.wakachi[_i] = IARRAY
    }
  }
}

// Watachiで生成した文節群をきれいにバルーンに並べる
InsertLineFeed.Render
{
  _result = ''

  // バルーンⅠ行あたりの文字数(標準的なバルーンなら24前後)
  _max = 0
  if ISVAR('forced_balloon_cols') {
    _max = forced_balloon_cols
  }
  else {
    _max = balloon_cols
  }

  // _wordcountはゴーストのスコープの数だけ要る とりあえず10確保
  _ary = IARRAY
  for _j=0; _j<10; _j++ {
    _ary = (_ary, 0.0)
  }
  _wordcount = _ary

  _scope = 0

  for _i=0; _i<ARRAYSIZE(InsertLineFeed.wakachi); _i++ {
    _bunsetu = InsertLineFeed.wakachi[_i]
    _wc = STRLENHALF(SHIORI3FW.RemoveAllTags(_bunsetu))

    // タグがスコープ変更(\0,\1,\p[2],...)なら、そのスコープを_scope変数に代入
    if RE_SEARCH(_bunsetu, '(\\[01][^w]?|\\p\[\d+\])') {
      _scope = TOINT(RE_REPLACE(RE_GETSTR()[0], '[^0-9]', ''))
    }

    // タグが改行(\n)などなら、そのスコープの文字数を0にする
    if RE_SEARCH(_bunsetu, '(\\n|\\_l\[0[,0-9em%]+\]|\\x|\\c)') {
      _wordcount[_scope] = 0
    }

    // 文字数が_maxを超えたら、改行を入れる
    if _wordcount[_scope] + _wc > _max {
      _result += '\n'
      _wordcount[_scope] = 0.0
    }

    _wordcount[_scope] += _wc
    _result += _bunsetu

    // 句読点後の文章が1行に収まるなら、一気に出力して次へ
    if RE_SEARCH(_bunsetu, '[、。！？]') {
      _nextline_words = ''
      _j = _i + 1
      while _j < ARRAYSIZE(InsertLineFeed.wakachi) {
        _b = InsertLineFeed.wakachi[_j]
        if RE_SEARCH(_b, '(\\n|\\_l\[0|\\x|\\c|\\[01]|\\p\[\d+\])') {
          _j--
          break
        }
        _nextline_words += _b
        _j++
      }

      _nextline_wordcount = STRLENHALF(SHIORI3FW.RemoveAllTags(_nextline_words))
      if _nextline_wordcount <= _max {
        // 句読点の後に改行を入れるのは、句読点の後の文章が1行に収まらない場合のみ
        if _max - _wordcount[_scope] < _nextline_wordcount {
          _result += '\n'
          _wordcount[_scope] = 0
        }
        _result += _nextline_words
        _wordcount[_scope] += _nextline_wordcount
        _i = _j
      }
    }
  }
  _result
}
