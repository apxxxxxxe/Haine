//******************************************************************************
//関数辞書
//******************************************************************************

//初期化処理
InitializeVariable
{
  "\![notify,OnNotifySelfInfo]"
  --
  "\![get,property,OnGetBalloonInfo,currentghost.balloon.name,currentghost.balloon.scope(0).lines]"
  --
  MakeKeroBalloownFollow
  --
  lastresponce = systemuptime
  uwanosora_minute = 5
  touch_count = 0
  last_touch_part = ''
  first_touch = 0
}

//\1バルーンを\0サーフェスに追従させる
MakeKeroBalloownFollow
{
  '\1\![set,alignmenttodesktop,free]\![move,0,0,0,0,left.top,left.top]\![set,sticky-window,1,0]'
}

//------------------------------------------------------------------------------
//朝/昼/夜などをおおざっぱに調べる関数
//------------------------------------------------------------------------------
GetTimeSlot
{
  case hour{
    when 22,23,0,1,2,3 {'深夜'}
    when 4,5,6,7,8,9,10,11 {'朝'}
    when 12,13 {'昼'}
    when 14,15,16,17 {'日中'}
    when 18,19,20,21 {'夜'}
  }
}

OnNotifySelfInfo
{
  sakura_name = reference[1]
  sakura_name = '郊外通りのハイネ'
}

OnGetBalloonInfo
{
  balloon.name = reference[0]
  balloon.lines = reference[1]
}

OnBalloonChange
{
  "\![get,property,OnGetBalloonInfo,,currentghost.balloon.name,currentghost.balloon.scope(0).lines]"
}


OnSurfaceChange
{
  current_surface = reference[0]
}

// サーフェス変更の際に目線が動くとき、なめらかに見えるようにまばたきのサーフェスを補完する関数
OnSurfaceComplete
{
  _delay = 100

  _dest_surface = TOINT(reference[0]) // 頬・眉・腕・口・目
  _dest_eyes = _dest_surface % 10 // 目
  _dest_remain = _dest_surface - _dest_eyes // 頬・眉・腕・口
  _from_surface = current_surface
  _from_eyes = _from_surface % 10
  _from_remain = _from_surface - _from_eyes

  _middle_surface = _dest_surface
  if (_from_eyes == 7 || _from_eyes == 9) && (_dest_eyes >= 1 && _dest_eyes <= 3) {
    //直前が目閉じかつ目標が全目の場合
    "\s[%(_dest_surface + 3)]"
  }
  elseif (_dest_eyes == 7 || _dest_eyes == 9) && (_from_eyes >= 1 && _from_eyes <= 3) {
    // 直前が全目かつ目標が目閉じの場合
    "\s[%(_dest_remain + _from_eyes + 3)]"
  }
  elseif (_dest_eyes >= 1 && _dest_eyes <= 3) && (_from_eyes >= 1 && _from_eyes <= 3) && (_from_eyes != _dest_eyes) {
    // 直前が全目かつ目標が全目の場合（直前と目標が同じ場合を除く）
    "\s[%(_from_surface + 3)]\_w[%(_delay)]\s[%(_dest_remain + 9)]\_w[%(_delay)]\s[%(_dest_surface + 3)]"
  }
  elseif (_dest_eyes >= 4 && _dest_eyes <= 6) && (_from_eyes >= 1 && _from_eyes <= 3) && ((_from_eyes + 3) != _dest_eyes) {
    // 直前が全目かつ目標が半目の場合（直前と目標が同じ場合, 直前と目標の目線方向が同じ場合を除く）
    "\s[%(_from_surface + 3)]\_w[%(_delay)]\s[%(_dest_remain + 9)]"
  }
  elseif (_dest_eyes >= 1 && _dest_eyes <= 3) && (_from_eyes >= 4 && _from_eyes <= 6) && ((_from_eyes - 3) != _dest_eyes) {
    // 直前が半目かつ目標が全目の場合（直前と目標が同じ場合, 直前と目標の目線方向が同じ場合を除く）
    "\s[%(_dest_remain + 9)]\_w[%(_delay)]\s[%(_dest_surface + 3)]"
  }
  else {
    "\s[%(_dest_surface)]"
    return
  }
  //--
  //"\_q_s:%(_dest_surface)\n_dest_eyes:%(_dest_eyes)\n_dest_remain:%(_dest_remain)\n_from_eyes:%(_from_eyes)\n_middle:%(_middle_surface)\_q\n"
  --
  "\_w[%(_delay)]\s[%(_dest_surface)]"
}

SETBALLOONSURFACE
{
  '\1\s[100000]\0\b[6]'
}

OnGetSurfaceInfo
{
  CurrentSurface = reference[0]
}

//現在のサーフェス番号を桁で分解して配列として返す
//10000の位:顔色 1000の位:眉 100の位:腕 10の位:口 1の位:目
GetSurfaceElements
{
  _e = CurrentSurface / POW(10, 5 - _argv[0]) % 10
  _e
}

ICON
{
  if (TOINT(_argv[1]) != 0) {
    _fontsize = _argv[1]
  } else{
    _fontsize = 12
  }

  "\f[cursorstyle,none]\f[height,%(_fontsize)]\f[name,icomoon.ttf]\_u[0x"
  --
  case _argv[0] {
    when 'stopwatch'   { 'e900' }
    when 'undo'        { 'e901' }
    when 'cog'         { 'e902' }
    when 'cross'       { 'e903' }
    when 'arrow-right' { 'e904' }
    when 'arrow-left'  { 'e905' }
    when 'bubble'      { 'e906' }
  }
  --
  ']\f[default]'
}

GETMIN
{
  _min = _argv[0]
  for _i=0; _i<_argc; _i++ {
    if _min > _argv[_i] { _min = _argv[_i] }
  }
  _min
}

//自動改行(特定の文字列の直後に改行するようにする)
AutoCRLF {
  _text = _argv[0]
  if STRLEN(_text) > 0 {
    _kugirimoji = (/
        "、", /
        "。", /
        "から", /
        "でも", /
        "や", /
        "で", /
        )
    _itigyou = 24
    _tmp = ''
    _idx = 0
    _crlf = -1
    _kugiri = -1
    _kugirilen = 0
    _cx = -1
    _n = 100
    for _j=0; _j<_n; _j++ { // _n回で強制終了
      _crlf = STRSTR(_text, '\n', _idx)
      if _crlf != -1 && _crlf < _itigyou {
        _idx = _idx + _crlf + 1
        _tmp += SUBSTR(_text, _idx, _crlf+1)
        continue
      }
      for _i=0; _i<ARRAYSIZE(_kugirimoji); _i++ {
        _kugiri = STRSTR(_text, _kugirimoji[_i], _idx)
        _kugirilen = STRLEN(_kugirimoji[_i]) - 1
        //タグ等があるから_itigyouは無意味かも...
        if _kugiri != -1 && _kugiri > (_itigyou / 2) && _kugiri < _itigyou { break }
      }
      if _crlf != -1 && _kugiri != -1 {
        _cx = GETMIN(_crlf, _kugiri + _kugirilen)
      } elseif _crlf != -1 && _kugiri == -1 {
        _cx = _crlf
      } elseif _crlf == -1 && _kugiri != -1 {
        _cx = _kugiri + _kugirilen
      } else { // _crlf == -1 && _kugiri == -1
        if _kugiri == -1 {
          break
        }
        _tmp += SUBSTR(_text, _idx, _cx+1) + '\n'
        _idx += _cx + 1
      }

      _tmp
      return
    }
  }
}

//******************************************************************************
//最小化からの復帰 OnWindowStateRestore
//******************************************************************************

OnWindowStateRestore
{
  'h100000h114109\_w[500]h114101'
  'h100000h111109\_w[500]h111103'
  'h100000h111105\_w[500]h111101'
}
