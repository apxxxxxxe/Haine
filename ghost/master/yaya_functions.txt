//******************************************************************************
//関数辞書
//******************************************************************************

//初期化処理
InitializeVariable
{
  GetGhostInfo
  --
  MakeKeroBalloownFollow
  --
  lastresponce = systemuptime
  uwanosora_minute = 5
  touch_count = 0
  last_touch_part = ''
  first_touch = 0
}

//\1バルーンを\0サーフェスに追従させる
MakeKeroBalloownFollow
{
  '\1\![set,alignmenttodesktop,free]\![move,0,0,0,0,left.top,left.top]\![set,sticky-window,1,0]'
}

//------------------------------------------------------------------------------
//朝/昼/夜などをおおざっぱに調べる関数
//------------------------------------------------------------------------------
GetTimeSlot
{
  case hour{
    when 22,23,0,1,2,3 {'深夜'}
    when 4,5,6,7,8,9,10,11 {'朝'}
    when 12,13 {'昼'}
    when 14,15,16,17 {'日中'}
    when 18,19,20,21 {'夜'}
  }
}

OngetGhostInfo
{
  // sakura側名
  sakura_name = reference[0]
  // 現在バルーン名
  balloon_name = reference[1]
  // 現在バルーンの最大行数
  balloon_lines = reference[2]
  // 現在バルーンのⅠ行あたりの最大文字数(おおよそ)
  balloon_cols = TOINT(reference[3] / reference[4] / 2)
}

OnBalloonChange
{
  GetGhostInfo
}

GetGhostInfo {
  "\![get,property,OngetGhostInfo,currentghost.sakuraname,currentghost.balloon.name,currentghost.balloon.scope(0).lines,currentghost.balloon.scope(0).validwidth.initial,currentghost.balloon.scope(0).char_width]"
}


OnSurfaceChange
{
  current_surface = reference[0]
}

// サーフェス変更の際に目線が動くとき、なめらかに見えるようにまばたきのサーフェスを補完する関数
OnSurfaceComplete
{
  _delay = 100

  _dest_surface = TOINT(reference[0]) // 頬・眉・腕・口・目
  _dest_eyes = _dest_surface % 10 // 目
  _dest_remain = _dest_surface - _dest_eyes // 頬・眉・腕・口
  _from_surface = current_surface
  _from_eyes = _from_surface % 10
  _from_remain = _from_surface - _from_eyes

  _middle_surface = _dest_surface
  if (_from_eyes == 7 || _from_eyes == 9) && (_dest_eyes >= 1 && _dest_eyes <= 3) {
    //直前が目閉じかつ目標が全目の場合
    "\s[%(_dest_surface + 3)]"
  }
  elseif (_dest_eyes == 7 || _dest_eyes == 9) && (_from_eyes >= 1 && _from_eyes <= 3) {
    // 直前が全目かつ目標が目閉じの場合
    "\s[%(_dest_remain + _from_eyes + 3)]"
  }
  elseif (_dest_eyes >= 1 && _dest_eyes <= 3) && (_from_eyes >= 1 && _from_eyes <= 3) && (_from_eyes != _dest_eyes) {
    // 直前が全目かつ目標が全目の場合（直前と目標が同じ場合を除く）
    "\s[%(_from_surface + 3)]\_w[%(_delay)]\s[%(_dest_remain + 9)]\_w[%(_delay)]\s[%(_dest_surface + 3)]"
  }
  elseif (_dest_eyes >= 4 && _dest_eyes <= 6) && (_from_eyes >= 1 && _from_eyes <= 3) && ((_from_eyes + 3) != _dest_eyes) {
    // 直前が全目かつ目標が半目の場合（直前と目標が同じ場合, 直前と目標の目線方向が同じ場合を除く）
    "\s[%(_from_surface + 3)]\_w[%(_delay)]\s[%(_dest_remain + 9)]"
  }
  elseif (_dest_eyes >= 1 && _dest_eyes <= 3) && (_from_eyes >= 4 && _from_eyes <= 6) && ((_from_eyes - 3) != _dest_eyes) {
    // 直前が半目かつ目標が全目の場合（直前と目標が同じ場合, 直前と目標の目線方向が同じ場合を除く）
    "\s[%(_dest_remain + 9)]\_w[%(_delay)]\s[%(_dest_surface + 3)]"
  }
  else {
    "\s[%(_dest_surface)]"
    return
  }
  //--
  //"\_q_s:%(_dest_surface)\n_dest_eyes:%(_dest_eyes)\n_dest_remain:%(_dest_remain)\n_from_eyes:%(_from_eyes)\n_middle:%(_middle_surface)\_q\n"
  --
  "\_w[%(_delay)]\s[%(_dest_surface)]"
}

SetBalloonSurface
{
  '\1\s[100000]\0\b[6]'
}

OnGetSurfaceInfo
{
  CurrentSurface = reference[0]
}

//現在のサーフェス番号を桁で分解して配列として返す
//10000の位:顔色 1000の位:眉 100の位:腕 10の位:口 1の位:目
GetSurfaceElements
{
  _e = CurrentSurface / POW(10, 5 - _argv[0]) % 10
  _e
}

// icomoon.ttfのアイコンを呼び出しやすくする関数
ICON
{
  if (TOINT(_argv[1]) != 0) {
    _fontsize = _argv[1]
  } else {
    _fontsize = 12
  }

  "\f[cursorstyle,none]\f[height,%(_fontsize)]\f[name,icomoon.ttf]\_u[0x"
  --
  case _argv[0] {
    when 'stopwatch'   { 'e900' }
    when 'undo'        { 'e901' }
    when 'cog'         { 'e902' }
    when 'cross'       { 'e903' }
    when 'arrow-right' { 'e904' }
    when 'arrow-left'  { 'e905' }
    when 'bubble'      { 'e906' }
  }
  --
  ']\f[default]'
}

GETMIN
{
  _min = _argv[0]
  for _i=0; _i<_argc; _i++ {
    if _min > _argv[_i] { _min = _argv[_i] }
  }
  _min
}

//自動改行(特定の品詞の単語の直後に改行するようにする。kisaragiが必要)
InsertLineFeed {
  // _argv[0]: 改行を入れたい文字列
  _text = SurfaceSnippet(_argv[0])
  // 返り値
  _result = ''
  // 直後に改行を入れる単語の品詞
  // primaryは該当単語が出現した時点で改行するが、secondaryはそれ以降にprimaryがない場合のみ改行する
  _class_primary = "記号-一般, 記号-読点, 記号-句点, 助詞-終助詞"
  _class_secondary = "助詞-格助詞-一般, 助詞-接続助詞, 助詞-係助詞, 助詞-副詞化, 助詞-副助詞, 連体詞, 名詞-接尾-一般"
  _class = _class_primary + ', ' + _class_secondary
  // バルーンⅠ行あたりの文字数
  /* なぜか動かないので塩漬け
     if ISVAR('balloon_cols') {
     _max = balloon_cols
     } else {
     _max = 24
     }
     */
  _max = 24
  // 閾値: これ以上の文字数で対象の単語が現れたときに改行する
  _threshold = TOINT(ROUND(_max / 3.0 * 2))
  // 内部処理に影響しなさそうな制御文字
  _mark = CHR(28)
  _mark2 = CHR(29)
  // 元の文字列を改行で区切って各々処理する
  _lines = SPLIT(_text, '\n')
  foreach _lines; _line {
    _linewordcount = 0
    _check = 0
    _wordcount = 0
    _check_wordcount = 0

    // 文字カウントに支障をきたすのでさくらスクリプトを目印用文字列に置換
    _l = RE_REPLACE(_line, '\\_{0,2}[a-zA-Z0-9*!&](\d|\[("([^"]|\\")+?"|([^\]]|\\\])+?)+?\])?', _mark)
    // 置換したさくらスクリプトは配列に保持しておいて適宜取り出す
    _tags = RE_GETSTR
    _linelen = STRLEN(_l) - ARRAYSIZE(_tags)
    _tagcount = 0

    _rank = FUNCTIONEX('SAORI\kisaragi\kisaragi.dll', 'parse', _l)
    for _i=0; _i<_rank-1; _i++ {
      // 最後の単語はEOSなのでrank-1でよい
      _word = valueex[_i][0, CHR(9)]
      _mc = RE_GREP(_word, _mark)
      if _mc {
        for _j=0; _j<_mc; _j++ {
          _tag = _tags[_tagcount]
          _result += _tags[_tagcount]
          _tagcount++
        }
      } else {
        _result += _word
        _wordcount += STRLEN(_word)
        _linewordcount += STRLEN(_word)
        if _wordcount > _max {
          // 改行されないまま次の行に達したときは文字カウントを修正
          if _check {
            _result = REPLACE(_result, _mark2, '\n')
            // 目印を改行に置換
            _wordcount -= _check_wordcount
            _check = 0
          } else {
            _wordcount %= _max
          }
        }
      }
      if RE_GREP(_class, valueex[_i+1][3, CHR(9)]) || /
        _wordcount < _threshold || /
        (_linelen - _linewordcount) <= (_max - _wordcount) {
          // 直後に改行対象があるときはなにもしない("……。"などでの不自然な改行を防ぐ)
          // 文字数が閾値以下ならなにもしない
          // _lの残り文字が現在行に収まるならなにもしない
          continue
        } elseif RE_GREP(_class_primary, valueex[_i][3, CHR(9)]) {
          // primaryに該当するなら改行
          _result = REPLACE(_result, _mark2, '')
          // 目印は不要なので削除
          _result += '\n'
          _wordcount = 0
          _check = 0
        } elseif RE_GREP(_class_secondary, valueex[_i][3, CHR(9)]) {
          // secondaryに該当するなら改行用の目印を置く
          _result = REPLACE(_result, _mark2, '')
          // 以前の目印は不要なので削除
          _result += _mark2
          _check_wordcount = _wordcount
          _check = 1
        }
    }
    // 元の文字列で改行されている位置に改行を挿入(すでに改行されていたらスキップ)
    if ! RE_GREP(_result, '\\n$') { _result += '\n' }
    _wordcount = 0
  }
  _result
}

SurfaceSnippet {
  _text = _argv[0]
  _text = RE_REPLACEEX(_text, "h([0-9]{6})", "\\0\\![embed,OnSurfaceComplete,$1]")
  _text
}

//******************************************************************************
//最小化からの復帰 OnWindowStateRestore
//******************************************************************************

OnWindowStateRestore
{
  'h100000h114109\_w[500]h114101'
  'h100000h111109\_w[500]h111103'
  'h100000h111105\_w[500]h111101'
}
