//******************************************************************************
//関数辞書
//******************************************************************************

//初期化処理
InitializeVariable
{
  "\![notify,OnNotifySelfInfo]"
  --
  "\![get,property,OnGetBalloonInfo,currentghost.balloon.name,currentghost.balloon.scope(0).lines]"
  --
  MakeKeroBalloownFollow
  --
  lastresponce = systemuptime
  uwanosora_minute = 5
  touch_count = 0
  last_touch_part = ''
  first_touch = 0
  wordcount = 0
}

//\1バルーンを\0サーフェスに追従させる
MakeKeroBalloownFollow
{
  '\1\![set,alignmenttodesktop,free]\![move,0,0,0,0,left.top,left.top]\![set,sticky-window,1,0]'
}

//------------------------------------------------------------------------------
//朝/昼/夜などをおおざっぱに調べる関数
//------------------------------------------------------------------------------
GetTimeSlot
{
  case hour{
    when 22,23,0,1,2,3 {'深夜'}
    when 4,5,6,7,8,9,10,11 {'朝'}
    when 12,13 {'昼'}
    when 14,15,16,17 {'日中'}
    when 18,19,20,21 {'夜'}
  }
}

OnNotifySelfInfo
{
  sakura_name = reference[1]
  sakura_name = '郊外通りのハイネ'
}

OnGetBalloonInfo
{
  balloon.name = reference[0]
  balloon.lines = reference[1]
}

OnBalloonChange
{
  "\![get,property,OnGetBalloonInfo,,currentghost.balloon.name,currentghost.balloon.scope(0).lines]"
}


OnSurfaceChange
{
  current_surface = reference[0]
}

// サーフェス変更の際に目線が動くとき、なめらかに見えるようにまばたきのサーフェスを補完する関数
OnSurfaceComplete
{
  _delay = 100

  _dest_surface = TOINT(reference[0]) // 頬・眉・腕・口・目
  _dest_eyes = _dest_surface % 10 // 目
  _dest_remain = _dest_surface - _dest_eyes // 頬・眉・腕・口
  _from_surface = current_surface
  _from_eyes = _from_surface % 10
  _from_remain = _from_surface - _from_eyes

  _middle_surface = _dest_surface
  if (_from_eyes == 7 || _from_eyes == 9) && (_dest_eyes >= 1 && _dest_eyes <= 3) {
    //直前が目閉じかつ目標が全目の場合
    "\s[%(_dest_surface + 3)]"
  }
  elseif (_dest_eyes == 7 || _dest_eyes == 9) && (_from_eyes >= 1 && _from_eyes <= 3) {
    // 直前が全目かつ目標が目閉じの場合
    "\s[%(_dest_remain + _from_eyes + 3)]"
  }
  elseif (_dest_eyes >= 1 && _dest_eyes <= 3) && (_from_eyes >= 1 && _from_eyes <= 3) && (_from_eyes != _dest_eyes) {
    // 直前が全目かつ目標が全目の場合（直前と目標が同じ場合を除く）
    "\s[%(_from_surface + 3)]\_w[%(_delay)]\s[%(_dest_remain + 9)]\_w[%(_delay)]\s[%(_dest_surface + 3)]"
  }
  elseif (_dest_eyes >= 4 && _dest_eyes <= 6) && (_from_eyes >= 1 && _from_eyes <= 3) && ((_from_eyes + 3) != _dest_eyes) {
    // 直前が全目かつ目標が半目の場合（直前と目標が同じ場合, 直前と目標の目線方向が同じ場合を除く）
    "\s[%(_from_surface + 3)]\_w[%(_delay)]\s[%(_dest_remain + 9)]"
  }
  elseif (_dest_eyes >= 1 && _dest_eyes <= 3) && (_from_eyes >= 4 && _from_eyes <= 6) && ((_from_eyes - 3) != _dest_eyes) {
    // 直前が半目かつ目標が全目の場合（直前と目標が同じ場合, 直前と目標の目線方向が同じ場合を除く）
    "\s[%(_dest_remain + 9)]\_w[%(_delay)]\s[%(_dest_surface + 3)]"
  }
  else {
    "\s[%(_dest_surface)]"
    return
  }
  //--
  //"\_q_s:%(_dest_surface)\n_dest_eyes:%(_dest_eyes)\n_dest_remain:%(_dest_remain)\n_from_eyes:%(_from_eyes)\n_middle:%(_middle_surface)\_q\n"
  --
  "\_w[%(_delay)]\s[%(_dest_surface)]"
}

SETBALLOONSURFACE
{
  '\1\s[100000]\0\b[6]'
}

OnGetSurfaceInfo
{
  CurrentSurface = reference[0]
}

//現在のサーフェス番号を桁で分解して配列として返す
//10000の位:顔色 1000の位:眉 100の位:腕 10の位:口 1の位:目
GetSurfaceElements
{
  _e = CurrentSurface / POW(10, 5 - _argv[0]) % 10
  _e
}

ICON
{
  if (TOINT(_argv[1]) != 0) {
    _fontsize = _argv[1]
  } else{
    _fontsize = 12
  }

  "\f[cursorstyle,none]\f[height,%(_fontsize)]\f[name,icomoon.ttf]\_u[0x"
  --
  case _argv[0] {
    when 'stopwatch'   { 'e900' }
    when 'undo'        { 'e901' }
    when 'cog'         { 'e902' }
    when 'cross'       { 'e903' }
    when 'arrow-right' { 'e904' }
    when 'arrow-left'  { 'e905' }
    when 'bubble'      { 'e906' }
  }
  --
  ']\f[default]'
}

GETMIN
{
  _min = _argv[0]
  for _i=0; _i<_argc; _i++ {
    if _min > _argv[_i] { _min = _argv[_i] }
  }
  _min
}

//自動改行(特定の文字列の直後に改行するようにする)
AutoCRLF {
  // _argv[0]: 改行を入れたい文字列
  _text = _argv[0]
  // 返り値
  _result = ''
  // 直後に改行を入れる文字列たち
  _kugirimoji = (/
      "、",   "記号-読点",    /
      "。",   "記号-句点",    /
      "から", "助詞-接続助詞",    /
      "も",   "助詞-係助詞",    /
      "は",   "助詞-係助詞",    /
      "に",   "助詞-副詞化",    /
      "や",   "助詞-並立助詞",    /
      "で",   "助詞-格助詞-一般",    /
      )
  _kc = ARRAYSIZE(_kugirimoji)
  // バルーンⅠ行あたりの文字数
  // 最終的にはプロパティシステムからとった値を反映する
  _itigyou = 24

  _flag = 0
  _wc = 0

  _mark = '࿚'
  _markcnt = 0
  _null = RE_GREP(_text, '\\_{0,2}[a-zA-Z0-9*!&](\d|\[("([^"]|\\")+?"|([^\]]|\\\])+?)+?\])?')
  _tags = RE_GETSTR
  _text = RE_REPLACE(_text, '\\_{0,2}[a-zA-Z0-9*!&](\d|\[("([^"]|\\")+?"|([^\]]|\\\])+?)+?\])?', _mark)

  _Rank = FUNCTIONEX('SAORI\kisaragi\kisaragi.dll', 'parse', _text)
  for _i=0; _i<_Rank; _i++ {
    _word = valueex[_i][0, CHR(9)]
    _mc = RE_GREP(_word, _mark)
    if _word == 'EOS' {
      continue
    } elseif _mc > 0 {
      for _j=0; _j<_mc; _j++ {
        if _tags[_markcnt] == '\0' || _tags[_markcnt] == '\1' || _tags[_markcnt] == '\n' { wordcount = 0 }
        _result += _tags[_markcnt]
        _markcnt++
      }
    } else {
      _wc = STRLEN(_word)
      wordcount += _wc
      _result += _word
    }
    for _j=0; _j<_kc; _j+=2 {
      if _flag == 1 || (_word == _kugirimoji[_j] && valueex[_i][3, CHR(9)] == _kugirimoji[_j+1]) {
        if wordcount > (_itigyou / 3 * 2) {
          _result += ' ' + wordcount + '\n'
          wordcount = 0
          _flag = 0
        }
        break
      }
    }
  }
  _result
}

// EraseTag: 以下より引用
// http://emily.shillest.net/ayaya/?Tips/SAKURA%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88%E3%82%BF%E3%82%B0%E3%82%92%E5%8F%96%E3%82%8A%E9%99%A4%E3%81%8F
EraseTag
{
  /*******************************************/
  /* SAKURAスクリプトタグのパターン          */
  /* ａ）"\" に続いて１文字                  */
  /* ｂ）"\" に続いて１個以上の "_" と１文字 */
  /* ｃ）（ａ）（ｂ）に続く "[" から "]"     */
  /* ｄ）（ａ）（ｂ）に続く１桁数字          */
  /* "\\" は "\" に                          */
  /* "[" から "]" の中の "\]" を考慮に入れる */
  /*******************************************/
  _str = ""
  while 1
  {
    if (_chr = SUBSTR(_argv[0],0,1)) != "\"
    {
      if _chr == "" ; break // 終端なら抜ける
        _str += _chr
        _argv[0] = ERASE(_argv[0],0,1)
    }
    else
    {
      _argv[0] = ERASE(_argv[0],0,1)

      //---- "_" を取り除く
      for _i = 0 ; (_chr = SUBSTR(_argv[0],0,1)) == "_" ; _i++
      {
        _argv[0] = ERASE(_argv[0],0,1)
      }
      if _chr == "" ; break // 終端なら抜ける

        //---- １文字削除する
        _argv[0] = ERASE(_argv[0],0,1)

        if     _chr == "0" && _i == 0 ; _str += "（０）"
          elseif _chr == "1" && _i == 0 ; _str += "（１）"
            elseif _chr == "\" && _i == 0 ; _str += "\"
        else
        {
          case SUBSTR(_argv[0],0,1)
          {
            //---- １桁数字を取り除く
            when "0","1","2","3","4","5","6","7","8","9"
            {
              _argv[0] = ERASE(_argv[0],0,1)
            }

            //---- "[" から "]" を取り除く（ネストに対応）
            //---- "\]" を考慮に入れる
            when "["
            {
              _argv[0] = ERASE(_argv[0],0,1)

              _chr = ""
              _nest = 0
              while _nest >= 0
              {
                _old = _chr
                _chr = SUBSTR(_argv[0],0,1)
                if     _chr == "" ; break // 終端なら抜ける
                  elseif _chr == "["                ; _nest++
                    elseif _chr == "]" && _old != "\" ; _nest--
                      _argv[0] = ERASE(_argv[0],0,1)
              }
            }
          }
        }
    }
  }

  //---- 見栄えを良くする
  _str = REPLACE(_str,"（０）（１）","（１）")
  _str = REPLACE(_str,"（１）（０）","（０）")
  _str = REPLACE(_str,"（０）（０）","（０）")
  _str = REPLACE(_str,"（１）（１）","（１）")

  _str
}

//******************************************************************************
//最小化からの復帰 OnWindowStateRestore
//******************************************************************************

OnWindowStateRestore
{
  'h100000h114109\_w[500]h114101'
  'h100000h111109\_w[500]h111103'
  'h100000h111105\_w[500]h111101'
}
