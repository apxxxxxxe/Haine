//******************************************************************************
//関数辞書
//******************************************************************************

// 初期化関数
// 変数が存在しない場合のみ代入する
InitVar
{
  _var_name = _argv[0]
  _value = _argv[1]
  if !ISVAR(_var_name) {
    EVAL(_var_name + "=" + _value)
  }
}

//初期化処理 起動毎に呼び出される
InitializeVariable
{
  GetProperties
  --
  MakeKeroBalloownFollow
  --

  //---- 変数の初期化(初回起動時のみ設定)
  InitVar('username', 'ユーザ')
  InitVar('teachusername', 0)
  InitVar('IsJihouActive', '有効')
  InitVar('circadian_rhythm', '設定しない')
  InitVar('isdebug', 0)
  InitVar('good_touch_count', 0)
  InitVar('bad_touch_count', 0)
  InitVar('total_talk_count', 0)
  InitVar('uwanosora_minute', 5)
  InitVar('hasSuicideInfo', 0)

  //---- 変数の初期化(起動毎に設定)
  lastresponce = systemuptime
  touch_count = 0
  last_touch_part = ''
  first_touch = 0
  isKeyBlocked = 0
}

//\1バルーンを\0サーフェスに追従させる
MakeKeroBalloownFollow
{
  '\1\![set,alignmenttodesktop,free]\![move,0,0,0,0,left.top,left.top]\![set,sticky-window,1,0]'
}

PosOffset
{
  _offset = balloon_rows
  if balloon_name == '霧の郊外にて' {
    _offset += 1
  }
  _offset += 'em'
  _offset
}

//------------------------------------------------------------------------------
//朝/昼/夜などをおおざっぱに調べる関数
//------------------------------------------------------------------------------
GetTimeSlot
{
  case hour {
    when 22,23,0,1,2,3

    {
      '深夜'
    }
    when 4,5,6,7,8,9,10,11

    {
      '朝'
    }
    when 12,13

    {
      '昼'
    }
    when 14,15,16,17

    {
      '日中'
    }
    when 18,19,20,21

    {
      '夜'
    }
  }
}

GetProperties
{
  GetGhostInfo
  --
  GetBalloonInfo
  --
  GetShellInfo
  --
  // GetShellInfo後に処理する必要があるのでembedで呼ぶ
  '\![embed,OnGetShellListInfo]'
}

GetGhostInfo
{
  '\![get,property,OnGetGhostInfo,currentghost.sakuraname]'
}

GetBalloonInfo
{
  '\![get,property,OnGetBalloonInfo,currentghost.balloon.name,currentghost.balloon.scope(0).lines,currentghost.balloon.scope(0).validwidth,currentghost.balloon.scope(0).char_width]'
}

GetShellInfo
{
  '\![get,property,OnGetShellInfo,currentghost.shelllist.current.name,currentghost.shelllist.count]'
}

OnGetGhostInfo
{
  //reference[0]: currentghost.sakuraname
  sakura_name = reference[0]
}

OnGetBalloonInfo
{
  //reference[0]: currentghost.balloon.name
  //reference[1]: currentghost.balloon.scope(0).lines
  //reference[2]: currentghost.balloon.scope(0).validwidth.initial
  //reference[3]: currentghost.balloon.scope(0).char_width

  balloon_name = reference[0]
  balloon_rows = reference[1]

  ERASEVAR('forced_balloon_cols')
  case balloon_name {
    when '霧の郊外にて' {
      balloon_cols = 24
    }
    when 'SSPデフォルト+' {
      balloon_cols = 24
    }
    others
    {
      _zenkaku_char_width = reference[3] * 2
      balloon_cols = TOINT(reference[2] / _zenkaku_char_width)
    }
  }
}

OnGetShellInfo
{
  //reference[0]: currentghost.shelllist.current.name
  //reference[1]: currentghost.shelllist.count
  shell_name = reference[0]
  shell_count = reference[1]
}

OnGetShellListInfo
{
  _cmd = '\![get,property,OnGetShellListInfoAfter,'
  for _i = 0; _i < shell_count; _i++ {
    _cmd += 'currentghost.shelllist.index(' + _i + ').name'
  }
  _cmd += ']'

  _cmd
}

OnGetShellListInfoAfter
{
  shell_list = IARRAY
  for _i = 0; _i < ARRAYSIZE(reference); _i++ {
    shell_list = (shell_list,reference[_i])
  }
}

OnBalloonChange
{
  GetBalloonInfo
}

OnSurfaceChange
{
  current_surface = reference[0]
}

// サーフェス変更の際に目線が動くとき、なめらかに見えるようにまばたきのサーフェスを補完する関数
OnSurfaceComplete
{
  _delay = 100

  _dest_surface = TOINT(reference[0]) // 頬・眉・腕・口・目
  _dest_eyes = _dest_surface % 10 // 目
  _dest_remain = _dest_surface - _dest_eyes // 頬・眉・腕・口
  _from_surface = current_surface
  _from_eyes = _from_surface % 10
  _from_remain = _from_surface - _from_eyes

  _middle_surface = _dest_surface
  if (_from_eyes == 7 || _from_eyes == 9) && (_dest_eyes >= 1 && _dest_eyes <= 3) {
    //直前が目閉じかつ目標が全目の場合
    "\s[%(_dest_surface + 3)]"
  }
  elseif (_dest_eyes == 7 || _dest_eyes == 9) && (_from_eyes >= 1 && _from_eyes <= 3) {
    // 直前が全目かつ目標が目閉じの場合
    "\s[%(_dest_remain + _from_eyes + 3)]"
  }
  elseif (_dest_eyes >= 1 && _dest_eyes <= 3) && (_from_eyes >= 1 && _from_eyes <= 3) && (_from_eyes != _dest_eyes) {
    // 直前が全目かつ目標が全目の場合（直前と目標が同じ場合を除く）
    "\s[%(_from_surface + 3)]\_w[%(_delay)]\s[%(_dest_remain + 9)]\_w[%(_delay)]\s[%(_dest_surface + 3)]"
  }
  elseif (_dest_eyes >= 4 && _dest_eyes <= 6) && (_from_eyes >= 1 && _from_eyes <= 3) && ((_from_eyes + 3) != _dest_eyes) {
    // 直前が全目かつ目標が半目の場合（直前と目標が同じ場合, 直前と目標の目線方向が同じ場合を除く）
    "\s[%(_from_surface + 3)]\_w[%(_delay)]\s[%(_dest_remain + 9)]"
  }
  elseif (_dest_eyes >= 1 && _dest_eyes <= 3) && (_from_eyes >= 4 && _from_eyes <= 6) && ((_from_eyes - 3) != _dest_eyes) {
    // 直前が半目かつ目標が全目の場合（直前と目標が同じ場合, 直前と目標の目線方向が同じ場合を除く）
    "\s[%(_dest_remain + 9)]\_w[%(_delay)]\s[%(_dest_surface + 3)]"
  }
  else {
    "\s[%(_dest_surface)]"
    return
  }
  --
  "\_w[%(_delay)]\s[%(_dest_surface)]"
}

SetBalloonSurfaceSakura
{
  '\0'
  --
  case _argv[0] {
    when 'large' {
      '\b[2]'
    }
    when 'garden' {
      '\b[4]'
    }
    when 'library' {
      '\b[6]'
    }
    when 'plain' {
      '\b[8]'
    }
    others
    {
      '\b[0]'
    }
  }
}

SetBalloonSurfaceKero
{
  '\1'
  --
  case _argv[0] {
    when 'living' {
      '\b[2]'
    }
    when 'large' {
      '\b[4]'
    }
    when 'garden' {
      '\b[6]'
    }
    when 'library' {
      '\b[8]'
    }
    when 'plain' {
      '\b[10]'
    }
    others
    {
      '\b[0]'
    }
  }
}

//現在のサーフェス番号を桁で分解して配列として返す
//10000の位:顔色 1000の位:眉 100の位:腕 10の位:口 1の位:目
GetSurfaceElements
{
  _e = current_surface / POW(10, 6 - _argv[0]) % 10
  _e
}

// icomoon.ttfのアイコンを呼び出しやすくする関数
ICON
{
  if (TOINT(_argv[1]) != 0) {
    _fontsize = _argv[1]
  }
  else {
    _fontsize = 12
  }

  "\f[cursorstyle,none]\f[height,%(_fontsize)]\f[name,icomoon.ttf]\_u[0x"
  --
  case _argv[0] {
    when 'stopwatch' {
      'e900'
    }
    when 'undo' {
      'e901'
    }
    when 'cog' {
      'e902'
    }
    when 'cross' {
      'e903'
    }
    when 'arrow-right' {
      'e904'
    }
    when 'arrow-left' {
      'e905'
    }
    when 'bubble' {
      'e906'
    }
    when 'info' {
      'e907'
    }
  }
  --
  ']\f[default]'
}

//自動改行(特定の品詞の単語の直後に改行するようにする。kisaragiが必要)
InsertLineFeed
{
  // _argv[0]: 改行を入れたい文字列
  _text = SurfaceSnippet(_argv[0])
  // 返り値
  _result = ''
  // 直前・直後に改行を入れる品詞と単語を列挙
  _htarget_pre = '名詞-一般'
  _target_pre = 'こと, もの, いる, みる, もらう, くれる, ほしい, おく, くる, とき, ない'
  _htarget_post = '感動詞, 記号-一般, 記号-読点, 記号-句点, 助詞-格助詞-一般, 助詞-格助詞-引用, 助詞-格助詞-連語, 助詞-係助詞, 助詞-終助詞, 助詞-接続助詞, 助詞-特殊, 助詞-副詞化, 助詞-副助詞, 助詞-並立助詞'
  _target_post = 'この, その, あの, どの'

  // バルーンⅠ行あたりの文字数
  _max = 0
  if ISVAR('forced_balloon_cols') {
    _max = forced_balloon_cols
  }
  else {
    _max = balloon_cols
  }

  // 内部処理に影響しなさそうな制御文字
  _tagmark = CHR(28)
  _kaigyoumark = CHR(29)

  _scope = 0

  // 元の文字列を改行で区切って各々処理する
  _lines = SPLIT(_text, '\n')
  for _i=0; _i<ARRAYSIZE(_lines); _i++ {
    _line = _lines[_i]
    _wordcount = (0, 0)
    _tmpwordcount = (0, 0)

    // 文字カウントに支障をきたすのでさくらスクリプトを目印用文字列に置換
    _l = RE_REPLACE(_line, '\\_{0,2}[a-zA-Z0-9*!&](\d|\[("([^"]|\\")+?"|([^\]]|\\\])+?)+?\])?', _tagmark)
    // 置換したさくらスクリプトは配列に保持しておいて適宜取り出す
    _tags = RE_GETSTR

    // 文末の全角・半角スペースは無駄なので消去
    _l = RE_REPLACE(_l, '[ 　]' + _tagmark + '*$', '')
    // 文全体の長さ
    _linelen = STRLEN(_l) - ARRAYSIZE(_tags)
    // さくらスクリプトを取り出す際のインデックス
    _tagcount = 0

    // 単語に分割する。_rankは単語の総数
    _rank = FUNCTIONEX('SAORI\kisaragi\kisaragi.dll', 'parse', _l)

    for _j=0; _j<_rank-1; _j++ {
      // 最後の単語はEOSなのでrank-1でよい

      // _wordに単語を取り出す
      _word = valueex[_j][0, CHR(9)]

      // _wordに_tagmark(さくらスクリプト)が含まれているかチェック
      // 通常の単語に含まれていること（例: りんご_tagmark）はなく、
      // _tagmark自体が連続して１単語とされることがある(例: _tagmark_tagmark)
      _tagmarkcount = RE_GREP(_word, _tagmark)
      if _tagmarkcount {
        // 含まれている場合、検出した数だけリストから取り出す
        for _k=0; _k<_tagmarkcount; _k++ {
          _tag = _tags[_tagcount]
          if RE_GREP(_tag, '\\[0-9][^w]?') {
            _scope = TOINT(REPLACE(RE_GETSTR()[0],'\',''))
          }
          if '\_l[0' _in_ _tag || '\x' _in_ _tag || '\c' _in_ _tag {
            _wordcount[_scope] = 0
          }
          _result += _tag
          _tagcount++
        }
      }
      else {
        // 通常の単語なら、_resultに追加して文字カウント
        _result += _word
        _wordcount[_scope] += STRLEN(_word)
      }

      // 品詞と単語を取り出して判定の準備
      _current_hinshi = valueex[_j][3, CHR(9)]
      _current_word = valueex[_j][0, CHR(9)]
      _next_hinshi = valueex[_j+1][3, CHR(9)]
      _next_word = valueex[_j+1][0, CHR(9)]

      // 実際に改行を挿入する処理
      if _wordcount[_scope] > _max {
        // 次の行に渡りそうなとき、最後に該当した文節部分で改行する
        if _kaigyoumark _in_ _result {
          _result = REPLACE(_result, _kaigyoumark, '\n')
          _wordcount[_scope] -= _tmpwordcount[_scope]
        }
        else {
          _wordcount[_scope] %= _max
        }
      }
      elseif /
        _current_hinshi _in_ _htarget_post || /
        _current_word _in_ _target_post || /
        _next_hinshi _in_ _htarget_pre && ! _current_hinshi _in_ _htarget_pre || /
        _current_word _in_ _target_post
        {
          // 改行候補になる文節に目印(_kaigyoumark)をつけておく
          _result = REPLACE(_result, _kaigyoumark, '')
          _result += _kaigyoumark
          _tmpwordcount[_scope] = _wordcount[_scope]
        }
    }

    // 元の文字列で改行されている位置に改行を挿入
    if _i < ARRAYSIZE(_lines)-1 {
      _result += '\n'
    }
  }
  _result
}

SurfaceSnippet
{
  RE_REPLACEEX(_argv[0], 'h([0-9]{6})', '\\0\\![embed,OnSurfaceComplete,$1]')
}

IsUnderLine
{
  if ! _argv[0] {
    '\f[strike,true]'
  }
}

OnTalkTopic
{
  _topicname = reference[0]
  if EVAL(_topicname) == 1 {
    EVAL(_topicname + '= 0')
  }
  else {
    EVAL(_topicname + '= 1')
  }
  '\C\c\![raise,OnTalkSettingMenu]'
}

ShowTopic
{
  '\_l[0,' + PosOffset + ']\f[height,11]\f[align,right]\![quicksection,true]'
  --
  case _argv[0] {
    when 'plants' {
      '植物の話題'
    }
    when 'aroma' {
      'アロマの話題'
    }
    when 'horrow' {
      '暗いフォークロア'
    }
    others
    {
      '日常の話題'
    }
  }
  --
  '\![quicksection,false]\_l[0,0]\f[default]'
}

FogHighlight
{
  _color = '160,192,192'
  '\f[color,' + _color + ']'
  --
  _argv[0]
  --
  '\f[color,default]'
}

UserRating
{
  UpdateUserRating

  _s = user_honesty
  if _s > 10 {
    'やさしいのね'
  }
  elseif _s < -10 {
    '欲望に忠実ね'
  }
  else {
    '久しぶりの客人'
  }
}

UpdateUserRating
{
  likability = good_touch_count + bad_touch_count + total_talk_count/3
  user_honesty = good_touch_count - bad_touch_count
}

//******************************************************************************
//最小化からの復帰 OnWindowStateRestore
//******************************************************************************

OnWindowStateRestore
{
  'h100000h111109\_w[500]h111101'
  'h100000h111109\_w[500]h111103'
  'h100000h111105\_w[500]h111101'
}

