//******************************************************************************
//関数辞書
//******************************************************************************

//初期化処理
InitializeVariable
{
  "\![notify,OnNotifySelfInfo]"
  --
  "\![get,property,OnGetBalloonInfo,currentghost.balloon.name,currentghost.balloon.scope(0).lines]"
  --
  MakeKeroBalloownFollow
  --
  lastresponce = systemuptime
  uwanosora_minute = 5
  touch_count = 0
  last_touch_part = ''
  first_touch = 0
}

//\1バルーンを\0サーフェスに追従させる
MakeKeroBalloownFollow
{
  '\1\![set,alignmenttodesktop,free]\![move,0,0,0,0,left.top,left.top]\![set,sticky-window,1,0]'
}

//------------------------------------------------------------------------------
//朝/昼/夜などをおおざっぱに調べる関数
//------------------------------------------------------------------------------
GetTimeSlot
{
  case hour{
    when 22,23,0,1,2,3 {'深夜'}
    when 4,5,6,7,8,9,10,11 {'朝'}
    when 12,13 {'昼'}
    when 14,15,16,17 {'日中'}
    when 18,19,20,21 {'夜'}
  }
}

OnNotifySelfInfo
{
  sakura_name = reference[1]
  sakura_name = '郊外通りのハイネ'
}

OnGetBalloonInfo
{
  balloon.name = reference[0]
  balloon.lines = reference[1]
}

OnBalloonChange
{
  "\![get,property,OnGetBalloonInfo,,currentghost.balloon.name,currentghost.balloon.scope(0).lines]"
}


OnSurfaceChange
{
  current_surface = reference[0]
}

// サーフェス変更の際に目線が動くとき、なめらかに見えるようにまばたきのサーフェスを補完する関数
OnSurfaceComplete
{
  _delay = 100

  _dest_surface = TOINT(reference[0]) // 頬・眉・腕・口・目
  _dest_eyes = _dest_surface % 10 // 目
  _dest_remain = _dest_surface - _dest_eyes // 頬・眉・腕・口
  _from_surface = current_surface
  _from_eyes = _from_surface % 10
  _from_remain = _from_surface - _from_eyes

  _middle_surface = _dest_surface
  if (_from_eyes == 7 || _from_eyes == 9) && (_dest_eyes >= 1 && _dest_eyes <= 3) {
    //直前が目閉じかつ目標が全目の場合
    "\s[%(_dest_surface + 3)]"
  }
  elseif (_dest_eyes == 7 || _dest_eyes == 9) && (_from_eyes >= 1 && _from_eyes <= 3) {
    // 直前が全目かつ目標が目閉じの場合
    "\s[%(_dest_remain + _from_eyes + 3)]"
  }
  elseif (_dest_eyes >= 1 && _dest_eyes <= 3) && (_from_eyes >= 1 && _from_eyes <= 3) && (_from_eyes != _dest_eyes) {
    // 直前が全目かつ目標が全目の場合（直前と目標が同じ場合を除く）
    "\s[%(_from_surface + 3)]\_w[%(_delay)]\s[%(_dest_remain + 9)]\_w[%(_delay)]\s[%(_dest_surface + 3)]"
  }
  elseif (_dest_eyes >= 4 && _dest_eyes <= 6) && (_from_eyes >= 1 && _from_eyes <= 3) && ((_from_eyes + 3) != _dest_eyes) {
    // 直前が全目かつ目標が半目の場合（直前と目標が同じ場合, 直前と目標の目線方向が同じ場合を除く）
    "\s[%(_from_surface + 3)]\_w[%(_delay)]\s[%(_dest_remain + 9)]"
  }
  elseif (_dest_eyes >= 1 && _dest_eyes <= 3) && (_from_eyes >= 4 && _from_eyes <= 6) && ((_from_eyes - 3) != _dest_eyes) {
    // 直前が半目かつ目標が全目の場合（直前と目標が同じ場合, 直前と目標の目線方向が同じ場合を除く）
    "\s[%(_dest_remain + 9)]\_w[%(_delay)]\s[%(_dest_surface + 3)]"
  }
  else {
    "\s[%(_dest_surface)]"
    return
  }
  //--
  //"\_q_s:%(_dest_surface)\n_dest_eyes:%(_dest_eyes)\n_dest_remain:%(_dest_remain)\n_from_eyes:%(_from_eyes)\n_middle:%(_middle_surface)\_q\n"
  --
  "\_w[%(_delay)]\s[%(_dest_surface)]"
}

SETBALLOONSURFACE
{
  '\1\s[100000]\0\b[6]'
}

OnGetSurfaceInfo
{
  CurrentSurface = reference[0]
}

//現在のサーフェス番号を桁で分解して配列として返す
//10000の位:顔色 1000の位:眉 100の位:腕 10の位:口 1の位:目
GetSurfaceElements
{
  _e = CurrentSurface / POW(10, 5 - _argv[0]) % 10
  _e
}

ICON
{
  if (TOINT(_argv[1]) != 0) {
    _fontsize = _argv[1]
  } else {
    _fontsize = 12
  }

  "\f[cursorstyle,none]\f[height,%(_fontsize)]\f[name,icomoon.ttf]\_u[0x"
  --
  case _argv[0] {
    when 'stopwatch'   { 'e900' }
    when 'undo'        { 'e901' }
    when 'cog'         { 'e902' }
    when 'cross'       { 'e903' }
    when 'arrow-right' { 'e904' }
    when 'arrow-left'  { 'e905' }
    when 'bubble'      { 'e906' }
  }
  --
  ']\f[default]'
}

GETMIN
{
  _min = _argv[0]
  for _i=0; _i<_argc; _i++ {
    if _min > _argv[_i] { _min = _argv[_i] }
  }
  _min
}

//自動改行(特定の文字列の直後に改行するようにする)
AutoCRLF {
  // _argv[0]: 改行を入れたい文字列
  _text = SurfaceSnippet(_argv[0])
  // 返り値
  _result = ''
  // 直後に改行を入れる単語の品詞
  _class = "記号-一般, 記号-読点, 記号-句点, 助詞-接続助詞, 助詞-係助詞, 助詞-副詞化, 助詞-並立助詞, 助詞-格助詞-一般, 助詞-終助詞"
  // バルーンⅠ行あたりの文字数
  _max = 24
  // 閾値: これ以上の文字数で対象の単語が現れたときに改行する
  _threshold = _max - 4

  _mark = CHR(28) // 内部処理に影響しなさそうな制御文字

  _lines = SPLIT(_text, '\n')
  _linecount = 0

  for _i=0; _i<ARRAYSIZE(_lines); _i++ {
    _line = _lines[_linecount]
    _flag = 0
    _markcount = 0
    _line = RE_REPLACE(_line, '\\_{0,2}[a-zA-Z0-9*!&](\d|\[("([^"]|\\")+?"|([^\]]|\\\])+?)+?\])?', _mark)
    _tags = RE_GETSTR

    _Rank = FUNCTIONEX('SAORI\kisaragi\kisaragi.dll', 'parse', _line)
    for _j=0; _j<_Rank; _j++ {
      _word = valueex[_j][0, CHR(9)]
      _mc = RE_GREP(_word, _mark)
      if _word == 'EOS' {
        break
      } elseif _mc > 0 {
        for _k=0; _k<_mc; _k++ {
          _tag = _tags[_markcount]
          if RE_GREP(_tag, '\\e|\n') {
            _wordcount = 0
          }
          _result += _tags[_markcount]
          _markcount++
        }
      } else {
        _result += _word
        _wordcount += STRLEN(_word)
        if _wordcount >= _max { // 改行されないまま次の行に達したときは文字カウントを修正
          _wordcount = _wordcount % _max
          _flag = 0
          continue
        }
      }
      if flag == 1 || RE_GREP(_class, valueex[_j][3, CHR(9)]) { // 区切り文字リストに_wordがあるか探す
        if RE_GREP(_class, valueex[_j+1][3, CHR(9)]) { // 直後に改行対象があるときは改行を延期("……。"などでの不自然な改行を防ぐ)
          _flag = 1
        } elseif _wordcount > _threshold { // 改行対象の位置が行の後半なら改行を挿入
          _result += '\n'
          _wordcount = 0
          _flag = 0
        }
      }
    }
    if ! RE_GREP(_result, '\\n$') { _result += '\n' }
    _wordcount = 0
    _linecount++
  }
  _result
}

SurfaceSnippet {
  _text = _argv[0]
  _text = RE_REPLACEEX(_text, "h([0-9]{6})", "\\0\\![embed,OnSurfaceComplete,$1]")
  _text
}

//******************************************************************************
//最小化からの復帰 OnWindowStateRestore
//******************************************************************************

OnWindowStateRestore
{
  'h100000h114109\_w[500]h114101'
  'h100000h111109\_w[500]h111103'
  'h100000h111105\_w[500]h111101'
}
