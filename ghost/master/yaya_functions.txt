//******************************************************************************
//関数辞書
//******************************************************************************

//初期化処理 起動毎に呼び出される
InitializeVariable
{
  GetProperties
  --
  MakeKeroBalloownFollow
  --
  lastresponce = systemuptime
  touch_count = 0
  last_touch_part = ''
  first_touch = 0
}

//\1バルーンを\0サーフェスに追従させる
MakeKeroBalloownFollow
{
  '\1\![set,alignmenttodesktop,free]\![move,0,0,0,0,left.top,left.top]\![set,sticky-window,1,0]'
}

PosOffset
{
  _offset = balloon_rows
  if balloon_name == "霧の郊外にて" {
    _offset += 1
  }
  _offset += "em"
  _offset
}

//------------------------------------------------------------------------------
//朝/昼/夜などをおおざっぱに調べる関数
//------------------------------------------------------------------------------
GetTimeSlot
{
  case hour{
    when 22,23,0,1,2,3 {'深夜'}
    when 4,5,6,7,8,9,10,11 {'朝'}
    when 12,13 {'昼'}
    when 14,15,16,17 {'日中'}
    when 18,19,20,21 {'夜'}
  }
}

GetProperties {
  GetGhostInfo
  --
  GetBalloonInfo
  --
  GetShellInfo
  --
  // GetShellInfo後に処理する必要があるのでembedで呼ぶ
  "\![embed,OnGetShellListInfo]"
}

GetGhostInfo {
  "\![get,property,OnGetGhostInfo,currentghost.sakuraname]"
}

GetBalloonInfo {
  "\![get,property,OnGetBalloonInfo,currentghost.balloon.name,currentghost.balloon.scope(0).lines,currentghost.balloon.scope(0).validwidth,currentghost.balloon.scope(0).char_width]"
}

GetShellInfo {
  "\![get,property,OnGetShellInfo,currentghost.shelllist.count]"
}

OnGetGhostInfo
{
  //reference[0]: currentghost.sakuraname
  sakura_name = reference[0]
}

OnGetBalloonInfo {
  //reference[0]: currentghost.balloon.name
  //reference[1]: currentghost.balloon.scope(0).lines
  //reference[2]: currentghost.balloon.scope(0).validwidth.initial
  //reference[3]: currentghost.balloon.scope(0).char_width

  balloon_name = reference[0]
  balloon_rows = reference[1]

  ERASEVAR("forced_balloon_cols")
  case balloon_name {
    when "霧の郊外にて" {
      balloon_cols = 26
    }
    when "SSPデフォルト+" {
      balloon_cols = 24
    }
    others {
      _zenkaku_char_width = reference[3] * 2
      balloon_cols = TOINT(reference[2] / _zenkaku_char_width)
    }
  }
}

OnGetShellInfo {
  //reference[0]: currentghost.shelllist.count
  shell_count = reference[0]
}

OnGetShellListInfo {
  _cmd = "\![get,property,OnGetShellListInfoAfter,"
  for _i = 0; _i < shell_count; _i++ {
    _cmd += "currentghost.shelllist.index(" + _i + ").name"
  }
  _cmd += "]"

  _cmd
}

OnGetShellListInfoAfter {
  shell_list = IARRAY
  for _i = 0; _i < ARRAYSIZE(reference); _i++ {
    shell_list = (shell_list,reference[_i])
  }
}

OnBalloonChange
{
  _balloon_name = reference[0]

  GetProperties
  --
  "\![embed,OnBalloonChangePost," + _balloon_name + "]"
}

OnBalloonChangePost {
}

OnSurfaceChange
{
  current_surface = reference[0]
}

// サーフェス変更の際に目線が動くとき、なめらかに見えるようにまばたきのサーフェスを補完する関数
OnSurfaceComplete
{
  _delay = 100

  _dest_surface = TOINT(reference[0]) // 頬・眉・腕・口・目
  _dest_eyes = _dest_surface % 10 // 目
  _dest_remain = _dest_surface - _dest_eyes // 頬・眉・腕・口
  _from_surface = current_surface
  _from_eyes = _from_surface % 10
  _from_remain = _from_surface - _from_eyes

  _middle_surface = _dest_surface
  if (_from_eyes == 7 || _from_eyes == 9) && (_dest_eyes >= 1 && _dest_eyes <= 3) {
    //直前が目閉じかつ目標が全目の場合
    "\s[%(_dest_surface + 3)]"
  }
  elseif (_dest_eyes == 7 || _dest_eyes == 9) && (_from_eyes >= 1 && _from_eyes <= 3) {
    // 直前が全目かつ目標が目閉じの場合
    "\s[%(_dest_remain + _from_eyes + 3)]"
  }
  elseif (_dest_eyes >= 1 && _dest_eyes <= 3) && (_from_eyes >= 1 && _from_eyes <= 3) && (_from_eyes != _dest_eyes) {
    // 直前が全目かつ目標が全目の場合（直前と目標が同じ場合を除く）
    "\s[%(_from_surface + 3)]\_w[%(_delay)]\s[%(_dest_remain + 9)]\_w[%(_delay)]\s[%(_dest_surface + 3)]"
  }
  elseif (_dest_eyes >= 4 && _dest_eyes <= 6) && (_from_eyes >= 1 && _from_eyes <= 3) && ((_from_eyes + 3) != _dest_eyes) {
    // 直前が全目かつ目標が半目の場合（直前と目標が同じ場合, 直前と目標の目線方向が同じ場合を除く）
    "\s[%(_from_surface + 3)]\_w[%(_delay)]\s[%(_dest_remain + 9)]"
  }
  elseif (_dest_eyes >= 1 && _dest_eyes <= 3) && (_from_eyes >= 4 && _from_eyes <= 6) && ((_from_eyes - 3) != _dest_eyes) {
    // 直前が半目かつ目標が全目の場合（直前と目標が同じ場合, 直前と目標の目線方向が同じ場合を除く）
    "\s[%(_dest_remain + 9)]\_w[%(_delay)]\s[%(_dest_surface + 3)]"
  }
  else {
    "\s[%(_dest_surface)]"
    return
  }
  //--
  //"\_q_s:%(_dest_surface)\n_dest_eyes:%(_dest_eyes)\n_dest_remain:%(_dest_remain)\n_from_eyes:%(_from_eyes)\n_middle:%(_middle_surface)\_q\n"
  --
  "\_w[%(_delay)]\s[%(_dest_surface)]"
}

SetBalloonSurface
{
  "\1\s[100000]\0"
  --
  case _argv[0] {
    when 'garden' {
      '\b[0]'
    }
    when 'library' {
      '\b[4]'
    }
    others {
      '\b[6]'
    }
  }
}

//現在のサーフェス番号を桁で分解して配列として返す
//10000の位:顔色 1000の位:眉 100の位:腕 10の位:口 1の位:目
GetSurfaceElements
{
  _e = current_surface / POW(10, 6 - _argv[0]) % 10
  _e
}

// icomoon.ttfのアイコンを呼び出しやすくする関数
ICON
{
  if (TOINT(_argv[1]) != 0) {
    _fontsize = _argv[1]
  } else {
    _fontsize = 12
  }

  "\f[cursorstyle,none]\f[height,%(_fontsize)]\f[name,icomoon.ttf]\_u[0x"
  --
  case _argv[0] {
    when 'stopwatch'   { 'e900' }
    when 'undo'        { 'e901' }
    when 'cog'         { 'e902' }
    when 'cross'       { 'e903' }
    when 'arrow-right' { 'e904' }
    when 'arrow-left'  { 'e905' }
    when 'bubble'      { 'e906' }
    when 'info'        { 'e907' }
  }
  --
  ']\f[default]'
}

//自動改行(特定の品詞の単語の直後に改行するようにする。kisaragiが必要)
InsertLineFeed {
  // _argv[0]: 改行を入れたい文字列
  _text = SurfaceSnippet(_argv[0])
  // 返り値
  _result = ''
  // 直後に改行を入れる単語の品詞
  _htarget_pre = "名詞-一般"
  _target_pre = "こと, もの, いる, みる, もらう, くれる, ほしい, おく, くる, とき, ない"
  _htarget_post = "感動詞, 記号-一般, 記号-読点, 記号-句点"
  _target_post = "この, その, あの, どの"

  // バルーンⅠ行あたりの文字数
  _max = 0
  if ISVAR("forced_balloon_cols") {
    _max = forced_balloon_cols
  } else {
    _max = balloon_cols
  }

  // 閾値: これ以上の文字数で対象の単語が現れたときに改行する
  _threshold = TOINT(_max / 3.0 * 2)

  // 内部処理に影響しなさそうな制御文字
  _mark = CHR(28)
  _mark2 = CHR(29)

  // 元の文字列を改行で区切って各々処理する
  _lines = SPLIT(_text, '\n')
  foreach _lines; _line {
    _linewordcount = 0
    _check = 0
    _wordcount = 0
    _check_wordcount = 0

    // 文字カウントに支障をきたすのでさくらスクリプトを目印用文字列に置換
    _l = RE_REPLACE(_line, '\\_{0,2}[a-zA-Z0-9*!&](\d|\[("([^"]|\\")+?"|([^\]]|\\\])+?)+?\])?', _mark)
    // 置換したさくらスクリプトは配列に保持しておいて適宜取り出す
    _tags = RE_GETSTR

    // 文末の全角・半角スペースは無駄なので消去
    _l = RE_REPLACE(_l, '[ 　]' + _mark + '*$', 'pro')
    // 文全体の長さ
    _linelen = STRLEN(_l) - ARRAYSIZE(_tags)
    // さくらスクリプトを取り出す際のインデックス
    _tagcount = 0

    // 単語に分割する。_rankは単語の総数
    _rank = FUNCTIONEX('SAORI\kisaragi\kisaragi.dll', 'parse', _l)

    for _i=0; _i<_rank-1; _i++ {
      // 最後の単語はEOSなのでrank-1でよい

      // _wordに単語を取り出す
      _word = valueex[_i][0, CHR(9)]

      // _wordに_mark(さくらスクリプト)が含まれているかチェック
      // 通常の単語に含まれていること（例: りんご_mark）はなく、
      // _mark自体が連続して１単語とされることがある(例: _mark_mark)
      _markcount = RE_GREP(_word, _mark)
      if _markcount {
        // 含まれている場合、検出した数だけリストから取り出す
        for _j=0; _j<_markcount; _j++ {
          _tag = _tags[_tagcount]

          if "\_l[0" _in_ _tag{
            _wordcount = 0
          }

          _result += _tag
          //_result += SHIORI3FW.EscapeAllTags(_tag)
          _tagcount++
        }
      } else {
        // 通常の単語なら、_resultに追加して文字カウント
        _result += _word
        _wordcount += STRLEN(_word)
        _linewordcount += STRLEN(_word)
        if _wordcount > _max {
          _wordcount %= _max
        }
      }

      _current_hinshi = valueex[_i][3, CHR(9)]
      _current_word = valueex[_i][0, CHR(9)]
      _next_hinshi = valueex[_i+1][3, CHR(9)]
      _next_word = valueex[_i+1][0, CHR(9)]

      // 改行の有無を確認し、必要なら改行する
      if _next_hinshi _in_ _htarget_post || /
        _wordcount < _threshold || /
        (_linelen - _linewordcount) <= (_max - _wordcount)
        {
          // ・直後に改行対象がある("……。"などでの不自然な改行を防ぐ)
          // ・文字数が閾値以下
          // 以上の場合は何もせず次の単語へ
          continue
        } elseif _current_hinshi _in_ _htarget_post || _current_word _in_ _target_post || /
      _next_hinshi _in_ _htarget_pre || _current_word _in_ _target_post
      {
        _result += '\n'
        _wordcount = 0
      }
    }
    // 元の文字列で改行されている位置に改行を挿入(すでに改行されていたらスキップ)
    if ! RE_GREP(_result, '\\n$')
    {
      _result += '\n'
      _wordcount = 0
    }
  }
  _result
}

SurfaceSnippet {
  _text = RE_REPLACEEX(_argv[0], "h([0-9]{6})", "\\0\\![embed,OnSurfaceComplete,$1]")
  _text
}

IsUnderLine {
  if ! _argv[0] {
    "\f[strike,true]"
  }
}

OnTalkTopic {
  _topicname = reference[0]
  if EVAL(_topicname) == 1 {
    EVAL(_topicname + "= 0")
  } else {
    EVAL(_topicname + "= 1")
  }
  "\C\c\![raise,OnTalkSettingMenu]"
}

ShowTopic {
  "\_l[0," + PosOffset + "]\f[height,11]\f[align,right]\![quicksection,true]"
  --
  case _argv[0] {
    when 'plants' {
      "植物の話題"
    }
    when 'aroma' {
      "アロマの話題"
    }
    when 'horrow' {
      "暗いフォークロア"
    }
    others {
      "日常の話題"
    }
  }
  --
  "\![quicksection,false]\_l[0,0]\f[default]"
}

UserEvaluation {
  if good_touch_count > bad_touch_count {
    // 常識人
  } else {
    // すけべ人間
  }
}

UserKoukando {
  _s = UpdateKoukando
  if _s > 10 {
    //好き
    'やさしい人'
  } elseif _s < -10 {
    //嫌い
    '苦手な人'
  } else {
    //どちらでもない
    'お客さん'
  }
}

UpdateKoukando {
  koukando = good_touch_count - bad_touch_count + total_talk_count/3
  koukando
}

//******************************************************************************
//最小化からの復帰 OnWindowStateRestore
//******************************************************************************

OnWindowStateRestore
{
  'h100000h111109\_w[500]h111101'
  'h100000h111109\_w[500]h111103'
  'h100000h111105\_w[500]h111101'
}

