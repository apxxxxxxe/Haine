//******************************************************************************
//関数辞書
//******************************************************************************

PosOffset
{
  _offset = balloon_rows
  if balloon_name == '霧の郊外にて' {
    _offset += 1
  }
  _offset += 'em'
  _offset
}

OnBalloonChange
{
  GetBalloonInfo
}

OnSurfaceChange
{
  current_surface = reference[0]
}

// サーフェス変更の際に目線が動くとき、なめらかに見えるようにまばたきのサーフェスを補完する関数
OnSurfaceComplete
{
  _delay = 100

  _dest_surface = TOINT(reference[0]) // 頬・眉・腕・口・目
  _dest_eyes = _dest_surface % 10 // 目
  _dest_remain = _dest_surface - _dest_eyes // 頬・眉・腕・口
  _from_surface = current_surface
  _from_eyes = _from_surface % 10
  _from_remain = _from_surface - _from_eyes

  _middle_surface = _dest_surface
  if (_from_eyes == 7 || _from_eyes == 9) && (_dest_eyes >= 1 && _dest_eyes <= 3) {
    //直前が目閉じかつ目標が全目の場合
    "\s[%(_dest_surface + 3)]"
  }
  elseif (_dest_eyes == 7 || _dest_eyes == 9) && (_from_eyes >= 1 && _from_eyes <= 3) {
    // 直前が全目かつ目標が目閉じの場合
    "\s[%(_dest_remain + _from_eyes + 3)]"
  }
  elseif (_dest_eyes >= 1 && _dest_eyes <= 3) && (_from_eyes >= 1 && _from_eyes <= 3) && (_from_eyes != _dest_eyes) {
    // 直前が全目かつ目標が全目の場合（直前と目標が同じ場合を除く）
    "\s[%(_from_surface + 3)]\_w[%(_delay)]\s[%(_dest_remain + 9)]\_w[%(_delay)]\s[%(_dest_surface + 3)]"
  }
  elseif (_dest_eyes >= 4 && _dest_eyes <= 6) && (_from_eyes >= 1 && _from_eyes <= 3) && ((_from_eyes + 3) != _dest_eyes) {
    // 直前が全目かつ目標が半目の場合（直前と目標が同じ場合, 直前と目標の目線方向が同じ場合を除く）
    "\s[%(_from_surface + 3)]\_w[%(_delay)]\s[%(_dest_remain + 9)]"
  }
  elseif (_dest_eyes >= 1 && _dest_eyes <= 3) && (_from_eyes >= 4 && _from_eyes <= 6) && ((_from_eyes - 3) != _dest_eyes) {
    // 直前が半目かつ目標が全目の場合（直前と目標が同じ場合, 直前と目標の目線方向が同じ場合を除く）
    "\s[%(_dest_remain + 9)]\_w[%(_delay)]\s[%(_dest_surface + 3)]"
  }
  else {
    "\s[%(_dest_surface)]"
    return
  }
  --
  "\_w[%(_delay)]\s[%(_dest_surface)]"
}

SetBalloonSurfaceSakura
{
  '\0'
  --
  case _argv[0] {
    when 'large' {
      '\b[2]'
    }
    when 'garden' {
      '\b[6]'
    }
    when 'library' {
      '\b[4]'
    }
    when 'plain' {
      '\b[8]'
    }
    others
    {
      '\b[0]'
    }
  }
}

SetBalloonSurfaceKero
{
  '\1'
  --
  case _argv[0] {
    when 'living' {
      '\b[2]'
    }
    when 'large' {
      '\b[4]'
    }
    when 'garden' {
      '\b[6]'
    }
    when 'library' {
      '\b[8]'
    }
    when 'plain' {
      '\b[10]'
    }
    others
    {
      '\b[0]'
    }
  }
}

//現在のサーフェス番号を桁で分解して配列として返す
//10000の位:顔色 1000の位:眉 100の位:腕 10の位:口 1の位:目
GetSurfaceElements
{
  _e = current_surface / POW(10, 6 - _argv[0]) % 10
  _e
}

// icomoon.ttfのアイコンを呼び出しやすくする関数
ICON
{
  if (TOINT(_argv[1]) != 0) {
    _fontsize = _argv[1]
  }
  else {
    _fontsize = 12
  }

  "\f[cursorstyle,none]\f[height,%(_fontsize)]\f[name,icomoon.ttf]\_u[0x"
  --
  case _argv[0] {
    when 'stopwatch' {
      'e900'
    }
    when 'undo' {
      'e901'
    }
    when 'cog' {
      'e902'
    }
    when 'cross' {
      'e903'
    }
    when 'arrow-right' {
      'e904'
    }
    when 'arrow-left' {
      'e905'
    }
    when 'bubble' {
      'e906'
    }
    when 'info' {
      'e907'
    }
  }
  --
  ']\f[default]'
}

//自動改行(特定の品詞の単語の直後に改行するようにする。kisaragiが必要)
InsertLineFeed
{
  // _argv[0]: 改行を入れたい文字列
  _text = SurfaceSnippet(_argv[0])
  // 返り値
  _result = ''
  // 直前・直後に改行を入れる品詞と単語を列挙
  _htarget_pre = '名詞-一般, 記号-括弧開'
  _target_pre = 'こと, もの, いる, みる, もらう, くれる, ほしい, おく, くる, とき, ない'
  _htarget_post = '/
  感動詞, /
  記号-一般, 記号-読点, 記号-句点, /
  助詞-係助詞, 助詞-格助詞-一般, 助詞-格助詞-引用, 助詞-格助詞-連語, 助詞-副助詞, /
  助詞-終助詞, 助詞-接続助詞, 助詞-特殊, 助詞-副詞化, 助詞-並立助詞, /
  '
  _target_post = 'この, その, あの, どの'

  // バルーンⅠ行あたりの文字数
  _max = 0
  if ISVAR('forced_balloon_cols') {
    _max = forced_balloon_cols
  }
  else {
    _max = balloon_cols
  }

  // 内部処理に影響しなさそうな制御文字
  _tagmark = CHR(28)
  _kaigyoumark = CHR(29)

  _scope = 0

  // 元の文字列を改行で区切って各々処理する
  _lines = SPLIT(_text, '\n')
  for _i=0; _i<ARRAYSIZE(_lines); _i++ {
    _line = _lines[_i]

    // _wordcountと_tmpwordcountはスコープの数だけ要る とりあえず10確保
    _ary = IARRAY
    for _j=0; _j<10; _j++ {
      _ary = (_ary, 0)
    }
    _wordcount = _ary
    _tmpwordcount = _ary

    // 文字カウントに支障をきたすのでさくらスクリプトを目印用文字列に置換
    _l = RE_REPLACE(_line, '\\_{0,2}[a-zA-Z0-9*!&](\d|\[("([^"]|\\")+?"|([^\]]|\\\])+?)+?\])?', _tagmark)
    // 置換したさくらスクリプトは配列に保持しておいて適宜取り出す
    _tags = RE_GETSTR

    // 文末の全角・半角スペースは無駄なので消去
    _l = RE_REPLACE(_l, '[ 　]' + _tagmark + '*$', '')
    // 文全体の長さ
    _linelen = STRLEN(_l) - (ARRAYSIZE(_tags) * STRLEN(_tagmark))
    // さくらスクリプトを取り出す際のインデックス
    _tagcount = 0

    // 単語に分割する。_rankは単語の総数
    _rank = FUNCTIONEX('SAORI\kisaragi\kisaragi.dll', 'parse', _l)

    for _j=0; _j<_rank-1; _j++ {
      // 最後の単語はEOSなのでrank-1でよい

      // _wordに平文の単語を取り出す
      _word = valueex[_j][0, CHR(9)]

      // _wordに_tagmark(さくらスクリプト)が含まれているかチェック
      _tagmarkcount = RE_GREP(_word, _tagmark)
      if _tagmarkcount {
        // 含まれている場合、検出した数だけリストから取り出して_tagmarkの位置に挿入
        for _k=0; _k<_tagmarkcount; _k++ {
          _tag = _tags[_tagcount]

          // タグがスコープ変更(\0,\1,\p[2],...)なら、そのスコープを_scope変数に代入
          if RE_GREP(_tag, '\\[01][^w]?') || RE_GREP(_tag, '\\p\[\d+\]') {
            _scope = TOINT(RE_REPLACE(RE_GETSTR()[0], '[^\d]', ''))
          }

          // カーソルを先頭に戻すタグなら文字カウントを0に
          if '\_l[0' _in_ _tag || '\x' _in_ _tag || '\c' _in_ _tag {
            _wordcount[_scope] = 0
          }

          _result += _tag
          _tagcount++
        }
      }
      else {
        // 通常の単語なら、_resultに追加して文字カウント
        _result += _word
        _wordcount[_scope] += STRLEN(_word)
      }

      // 品詞と単語を取り出して判定の準備
      _current_hinshi = valueex[_j][3, CHR(9)]
      _current_word = valueex[_j][0, CHR(9)]
      _next_hinshi = valueex[_j+1][3, CHR(9)]
      _next_word = valueex[_j+1][0, CHR(9)]

      // 実際に改行を挿入する処理
      if _wordcount[_scope] > _max {
        // 次の行に渡りそうなとき、最後に該当した文節部分で改行する
        if _kaigyoumark _in_ _result {
          _result = REPLACE(_result, _kaigyoumark, '\n')
          _wordcount[_scope] -= _tmpwordcount[_scope]
        }
        else {
          _wordcount[_scope] %= _max
        }
      }
      elseif /
        _current_hinshi _in_ _htarget_post || /
        _current_word _in_ _target_post || /
        _next_hinshi _in_ _htarget_pre && ! _current_hinshi _in_ _htarget_pre || /
        _current_word _in_ _target_post
        {
          // 改行候補になる文節に目印(_kaigyoumark)をつけておく
          _result = REPLACE(_result, _kaigyoumark, '')
          _result += _kaigyoumark
          _tmpwordcount[_scope] = _wordcount[_scope]
        }
    }

    // 元の文字列で改行されている位置に改行を挿入
    if _i < ARRAYSIZE(_lines)-1 {
      _result += '\n'
    }
  }
  _result
}

SurfaceSnippet
{
  RE_REPLACEEX(_argv[0], 'h([0-9]{6})', '\\0\\![embed,OnSurfaceComplete,$1]')
}

IsUnderLine
{
  if ! _argv[0] {
    '\f[strike,true]'
  }
}

OnTalkTopic
{
  _topicname = reference[0]
  if EVAL(_topicname) == 1 {
    EVAL(_topicname + '= 0')
  }
  else {
    EVAL(_topicname + '= 1')
  }
  '\C\c\![raise,OnTalkSettingMenu]'
}

ShowTopic
{
  '\_l[0,' + PosOffset + ']\f[height,11]\f[align,right]\![quicksection,true]'
  --
  case _argv[0] {
    when 'plants' {
      '植物の話題'
    }
    when 'aroma' {
      'アロマの話題'
    }
    when 'horrow' {
      '暗いフォークロア'
    }
    when 'life' {
      '日常の話題'
    }
    others
    {
      _argv[0]
    }
  }
  --
  '\![quicksection,false]\_l[0,0]\f[default]'
}

FogHighlight
{
  _color = '160,192,192'
  '\f[color,' + _color + ']'
  --
  _argv[0]
  --
  '\f[color,default]'
}

UserRating
{
  UpdateUserRating

  _s = user_honesty
  if _s > 10 {
    'やさしいのね'
  }
  elseif _s < -10 {
    '欲望に忠実ね'
  }
  else {
    '久しぶりの客人'
  }
}

UpdateUserRating
{
  likability = good_touch_count + bad_touch_count + total_talk_count/3
  user_honesty = good_touch_count - bad_touch_count
}

//******************************************************************************
//最小化からの復帰 OnWindowStateRestore
//******************************************************************************

OnWindowStateRestore
{
  'h100000h111109\_w[500]h111101'
  'h100000h111109\_w[500]h111103'
  'h100000h111105\_w[500]h111101'
}

//******************************************************************************
//時刻系関数
//******************************************************************************

CompareTime
{
  // 時刻の大小を比べて返す関数
  // 前者をa,後者をbとすると、
  // a > b :  1
  // a < b : -1
  // a = b :  0
  // を返す。

  // _argv[0]: a.hour
  // _argv[1]: a.minute
  // _argv[2]: a.second
  // _argv[3]: b.hour
  // _argv[4]: b.minute
  // _argv[5]: b.second

  _a.hour   = _argv[0]
  _a.minute = _argv[1]
  _a.second = _argv[2]
  _b.hour   = _argv[3]
  _b.minute = _argv[4]
  _b.second = _argv[5]

  if _a.hour > _b.hour {
    1
  }
  elseif _a.hour < _b.hour {
    -1
  }
  else {
    if _a.minute > _b.minute {
      1
    }
    elseif _a.minute < _b.minute {
      -1
    }
    else {
      if _a.second > _a.second {
        1
      }
      elseif _a.second < _a.second {
        -1
      }
      else {
        0
      }
    }
  }
}

CalcTime
{
  // _argv[0]: hour
  // _argv[1]: minute
  // _argv[2]: second
  // _argv[3]: 差分minute

  _hour = _argv[0]
  _minute = _argv[1] + _argv[3]
  _second = _argv[2]

  if _minute > 60 {
    _hour += _minute / 60 % 24
    _minute %= 60
  }
  elseif _minute < 0 {
    _hour -= (-1*_minute) / 60 + 1
    while _hour < 0
    {
      _hour += 24
    }
    while _minute < 0
    {
      _minute += 60
    }
  }

  (_hour, _minute, _second)
}

GetTimeSlot
{
  if CompareTime(now, CalcTime(sunrisetime, -30)) >= 0 && CompareTime(now, sunrisetime) < 0 {
    // 日の出30分前～日の出
    '日の出直前'
    return
  }
  elseif CompareTime(now, CalcTime(sunrisetime, 30)) < 0 && CompareTime(now, sunrisetime) >= 0 {
    // 日の出～日の出30分後
    '日の出直後'
    return
  }
  elseif CompareTime(now, CalcTime(sunsettime, -30)) >= 0 && CompareTime(now, sunsettime) < 0 {
    // 日没30分前～日没
    '黄昏時'
    return
  }
  elseif CompareTime(now, CalcTime(sunsettime, 30)) < 0 && CompareTime(now, sunsettime) >= 0 {
    // 日没～日没30分後
    '日没直後'
    return
  }

  case now[0] {
    when 22,23,0,1,2,3 {
      '深夜'
    }
    when 4,5,6,7,8,9,10,11 {
      '朝'
    }
    when 12,13 {
      '昼'
    }
    when 14,15,16,17 {
      '日中'
    }
    when 18,19,20,21 {
      '夜'
    }
  }
}

